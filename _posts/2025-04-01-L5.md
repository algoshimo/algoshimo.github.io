---
title: '程序和进程/进程的地址空间'
date: 2025-04-01
permalink: /posts/jyyos-2025/process/
categories : [jyyos-2025]
#excerpt : "点击查看全文"
---

###立即复制状态机 : fork()
复制进程的所有状态 ： 寄存器，每一个字节的内存

区分这两个状态机的唯一方式 : 返回值不同

思考一个问题 : 
进程的父子关系中 ：A->B->C，B终止了，C的ppid是什么

B运行waitpid()等待C进程结束，C进程结束时会发送一个信号给父进程。
加入C还没有结束，B进程就被终止，C进程结束后的信号该发送到哪?

一个自然的思维是将子进程托孤给父进程的父进程，但很有可能出现连环托孤问题。
于是unix的设计者决定将托孤给一个不会被终止的进程: init/systemd

一个示例代码可以帮助我们验证
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();  // 创建子进程

    if (pid == 0) {
        // 子进程
        printf("Child PID: %d, Parent PID: %d\n", getpid(), getppid());
        sleep(10);  // 子进程休眠 10 秒，等待父进程退出
        printf("Child now has new parent: %d\n", getppid());
    } else {
        // 父进程
        printf("Parent PID: %d\n", getpid());
        sleep(2);  // 父进程休眠 2 秒后退出
    }
    return 0;
}
```